#!/usr/bin/perl -w

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
# 
#----------------------------------------------------------------------
# \file    svnall
#
# \author  Tobias Foehst
#
# \date    2010-11-10
#
#----------------------------------------------------------------------

use strict;

use Env '$FINROC_HOME';

use Data::Dumper;
use XML::Simple;

use lib "$FINROC_HOME/scripts/perl";
use FINROC::messages;
use FINROC::getopt;



############################
##  Command line options  ##
############################

SetHelp undef,
{
    "-e, --externals" => "Process svn:externals (by not adding --ignore-externals)"    
}, "To add options to svn commands terminate options processing using '--'\n";

ParseCommandLine [ "externals" ], undef;

# non-optional arguments
ERRORMSG sprintf "<svn_command> not specified. Use %s --help for more information.\n", ScriptName unless defined $ARGV[0];



############################
##  Find svn directories  ##
############################

sub GetRepositoryInfo($)
{
    my ($directory) = @_;
    my $svn_info = `svn info --xml $directory`;
    my %svn_info = %{${XMLin $svn_info}{"entry"}};
    return { "directory" => $directory, "url" => $svn_info{"url"}, "root" => $svn_info{"repository"}{"root"}, "uuid" => $svn_info{"repository"}{"uuid"} };
}

my @directories = map { GetRepositoryInfo $_ } sort map { s/\/\.svn$//; $_ } split "\n", `find -name ".svn"`;

DEBUGMSG Dumper \@directories;

my @parents;
my @svn_directories;
foreach my $directory (@directories)
{
    unless (scalar @parents)
    {
        push @parents, { "directory" => ${$directory}{"directory"}, "uuid" => ${$directory}{"uuid"} };
        push @svn_directories, $directory;
        next;
    }
    if (${$directory}{"uuid"} ne $parents[-1]{"uuid"})
    {
        while (scalar @parents and $parents[-1]{"directory"} ne substr ${$directory}{"directory"}, 0, length $parents[-1]{"directory"})
        {
            pop @parents;
        }
    }
    if (${$directory}{"uuid"} ne $parents[-1]{"uuid"})
    {
        push @parents, { "directory" => ${$directory}{"directory"}, "uuid" => ${$directory}{"uuid"} };
        push @svn_directories, $directory;
    }
}

DEBUGMSG Dumper \@svn_directories;



##############################################
##  Execute command in every svn directory  ##
##############################################

my $svn_command = join " ", @ARGV;
#my %conflicts;

my $working_directory = sprintf "%s", map { chomp; $_ } `pwd`;
DEBUGMSG sprintf "Stored working directory: '%s'\n", $working_directory;
foreach my $svn_directory (@svn_directories)
{
    DEBUGMSG sprintf "Processing '%s'\n", ${$svn_directory}{"directory"};

    DEBUGMSG sprintf "cd %s\n", ${$svn_directory}{"directory"};
    chdir ${$svn_directory}{"directory"};

    INFOMSG sprintf "\nWorking copy of %s at %s\n", ${$svn_directory}{"url"}, map { chomp; $_ } `pwd`;

    my $command = sprintf "svn %s %s", defined GetCommandLineOption "externals" ? "" : "--ignore-externals", $svn_command;
    INFOMSG sprintf "Executing '%s'\n", $command;
    system $command;
#    my $conflicts = 0;
#    foreach (split "\n", `$command`)
#    {
#        print;
#        print "\n";
#        $conflicts++ if /^\s*U\s+/;
#    }
#    $conflicts{${$svn_directory}{"directory"}} = $conflicts if $conflicts;

    DEBUGMSG sprintf "cd %s\n", $working_directory;
    chdir $working_directory;
}
INFOMSG "\n";



############################
##  Tell about conflicts  ##
############################

#foreach my $directory (keys %conflicts)
#{
#    printf "There %s %d conflict%s at %s\n", $conflicts{$directory} == 1 ? "is" : "are", $conflicts{$directory}, $conflicts{$directory} == 1 ? "" : "s", $directory;
#}



exit 0;
