#!/usr/bin/perl -w

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
# 
#----------------------------------------------------------------------
# \file    finroc_get
#
# \author  Tobias Foehst
#
# \date    2010-04-07
#
#----------------------------------------------------------------------

use strict;

use Env '$FINROC_HOME';

use Getopt::Long;
use Data::Dumper;

use lib "$FINROC_HOME/scripts/perl";
use FINROC::messages;



############################
##  Command line options  ##
############################

# command line options
my %command_line_options;
GetOptions \%command_line_options, "verbose+", "help", "recurse", "optional=s";

EnableVerboseMessages if defined $command_line_options{"verbose"};

DEBUGMSG sprintf "command line options:\n%s\n", Dumper \%command_line_options;

# handle illegal values
if (defined $command_line_options{"optional"})
{
    ERRORMSG "Possible values for --optional: yes|no|ask\n" unless $command_line_options{"optional"} =~ /yes|no|ask/;
    ERRORMSG "Option optional has no effect without --recurse\n" unless defined $command_line_options{"recurse"};
}



#############
##  Usage  ##
#############

# print help and terminate if requested
if (defined $command_line_options{"help"})
{
    sub PrintOption($$) { INFOMSG sprintf "  %-34s %s\n", @_; }

    INFOMSG sprintf "usage: %s [options] <repository_list>\n", (reverse (split "/", $0))[0];
    INFOMSG "options:\n";
    PrintOption "-h, --help", "show this help";
    PrintOption "-v, --verbose", "more output for debugging";
    PrintOption "-r, --recursive", "get dependencies";
    PrintOption "-o [yes|no], --optional=[yes|no]", "get optional dependencies? - default: ask";
    INFOMSG "\n";
    exit 0;
}



# non-optional arguments
ERRORMSG sprintf "<repository_list> not specified. Use %s --help for more information.\n", (reverse (split "/", $0))[0] unless defined $ARGV[0];



# default values if not set
$command_line_options{"optional"} = "ask" unless defined $command_line_options{"optional"} and $command_line_options{"optional"} ne "";



###########################
#  Component information  #
###########################

sub ComponentInfo($$) { return ( shift, { "directory" => "$FINROC_HOME/".shift, "selected" => 0, "processed" => 0 } ); }

sub FINROC($)
{
    my ($name) = @_;
    return ComponentInfo "finroc_core", "core" if $name =~ /^core$/;
    return ComponentInfo "finroc_jcore", "jcore" if $name =~ /^jcore$/;
    return ComponentInfo "finroc_plugins_$1", "plugins/$1" if $name =~ /^plugins_(.*)/;
    return ComponentInfo "finroc_libraries_$1", "libraries/$1" if $name =~ /^libraries_(.*)/;
    return ComponentInfo "finroc_tools_jgui_plugins_$1", "tools/jgui/plugins/$1" if $name =~ /^tools_jgui_plugins_(.*)/;
    return ComponentInfo "finroc_tools_$1", "tools/$1" if $name =~ /^tools_(.*)/;
    return ComponentInfo "finroc_projects_$1", "projects/$1" if $name =~ /^projects_(.*)/;
    ERRORMSG sprintf "Could not identify FINROC component '%s'\n", $name;
}

sub RRLib($)
{
    my ($name) = @_;
    return ComponentInfo "rrlib_$name", "rrlib/$name";
}

sub Local($)
{
    my ($name) = @_;
    my $directory = `pwd`;
    ERRORMSG "Processing of local component within mca2-legacy directory is not supported!\n" if $directory =~ /\/mca2-legacy\//;   # FIXME: ONLY FOR MCA2 LEGACY
    return FINROC "plugins_$name" if $directory =~ /\/plugins$/;
    return FINROC "libraries_$name" if $directory =~ /\/libraries$/;
    return FINROC "tools_$name" if $directory =~ /\/tools$/;
    return FINROC "projects_$name" if $directory =~ /\/projects$/;
    return RRLib $name if $directory =~ /\/rrlib$/;
    ERRORMSG sprintf "Could not identify component '%s'\n", $name;
}



#########################
#  MCA2 legacy support  #
#########################

sub MCA2($)
{
    my ($name) = @_;
    return ComponentInfo "mca2", "mca2-legacy" if $name =~ /^2$/;
    return ComponentInfo "mcal_$1", "mca2-legacy/libraries/$1" if $name =~ /^l_(.*)/;
    return ComponentInfo "mcap_$1", "mca2-legacy/projects/$1" if $name =~ /^p_(.*)/;
    return ComponentInfo "mcar_$1", "mca2-legacy/resources/$1" if $name =~ /^r_(.*)/;
    ERRORMSG sprintf "Could not identify MCA2 legacy component '%s'\n", $name;
}



#######################################
#  Process components (repositories)  #
#######################################

my %components;

sub Component($)
{
    my ($name) = @_;
    return FINROC $1 if $name =~ /^finroc_(.*)/;
    return RRLib $1 if $name =~ /^rrlib_(.*)/;
    return MCA2 $1 if $name =~ /^mca(.*)/;
    return Local $name;
    ERRORMSG sprintf "Could not identify component '%s'\n", $name;
}

sub AddMandatoryComponent
{
    my ($name, $data) = @_;
    $components{$name} = $data unless exists $components{$name};
    $components{$name}{"selected"} = 1;
}

sub AddOptionalComponent
{
    my ($name, $data) = @_;
    $components{$name} = $data unless exists $components{$name};
}



foreach my $component (@ARGV)
{
    AddMandatoryComponent Component $component;
}

DEBUGMSG sprintf "components:\n%s\n", Dumper \%components;



#########################
#  Handle dependencies  #
#########################

sub AddDependencies($)
{
    my ($directory) = @_;

    my $dependencies_filename = sprintf "%s/.dependencies", $directory;
    open DEPENDENCIES, "<$dependencies_filename" and eval {
        while (<DEPENDENCIES>)
        {
            chomp;
            AddMandatoryComponent Component $_;
        }
        close DEPENDENCIES;
        1;
    } or DEBUGMSG sprintf "Could not read '%s'\n", $dependencies_filename;

    my $optional_dependencies_filename = sprintf "%s/.optional_dependencies", $directory;
    open DEPENDENCIES, "<$optional_dependencies_filename" and eval {
        while (<DEPENDENCIES>)
        {
            chomp;
            AddOptionalComponent Component $_;
        }
        close DEPENDENCIES;
        1;
    } or DEBUGMSG sprintf "Could not read '%s'\n", $optional_dependencies_filename;
}

sub FixImplicitDependencies()
{
    foreach my $name (sort keys %components)
    {
        AddMandatoryComponent Component "finroc_tools_jgui" if $name =~ /^finroc_tools_jgui_/;
        AddMandatoryComponent Component "mca2" if $name =~ /^mca/; # FIXME: ONLY FOR MCA2 LEGACY
    }
}

sub AskForOptionalComponent($)
{
    my ($dependency) = @_;

    INFOMSG sprintf "Get optional component '%s'? [yes/No] ", $dependency;
    return <STDIN> =~ /^y/;
}



###########################
#  Checkout repositories  #
###########################

sub Checkout($$)
{
    my ($repository, $directory) = @_;
    $repository = sprintf "https://agrosy.informatik.uni-kl.de/svn/%s/trunk", $repository;
    $repository =~ s/mca2\/trunk$/mca2\/branches\/mca3_experimental/; # FIXME: ONLY FOR MCA2 LEGACY
    ERRORMSG sprintf "'%s' should be used for working copy but is a file\n", $directory if -f $directory;
    ERRORMSG sprintf "'%s' already exists\n", $directory if -e $directory;

    my $command = sprintf "svn co %s %s", $repository, $directory;
    INFOMSG sprintf "Executing '%s'\n", $command;
    system $command;
}



my $complete = 0;
while (!$complete)
{
    # mandatory (or selected optional)
    while (!$complete)
    {
        FixImplicitDependencies;
        $complete = 1;
        foreach my $name (sort keys %components)
        {
            next unless $components{$name}{"selected"};
            next if $components{$name}{"processed"};
            next if -d $components{$name}{"directory"};
            $complete = 0;

            DEBUGMSG sprintf "Processing '%s'\n%s\n", $name, Dumper \$components{$name};

            Checkout $name, $components{$name}{"directory"};
            AddDependencies $components{$name}{"directory"} if defined $command_line_options{"recurse"};

            $components{$name}{"processed"} = 1;
        }
    }

    # optional
    unless ($command_line_options{"optional"} eq "no")
    {
        foreach my $name (sort keys %components)
        {
            next if $components{$name}{"selected"};
            next if $components{$name}{"processed"};
            next if -d $components{$name}{"directory"};
            $complete = 0;
            
            if ($command_line_options{"optional"} eq "yes" or AskForOptionalComponent $name)
            {
                $components{$name}{"selected"} = 1;
                next;
            }

            $components{$name}{"processed"} = 1;
        }
    }
}



exit 0;
